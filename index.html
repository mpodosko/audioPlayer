<!DOCTYPE html>
<html lang="en">
<head><script>/*window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n, ${line}:${col}`);
};*/</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
        ㅤ
  </title>
  <link rel="shortcut icon" id=favicon">
  <style>
    :root {
      --cbuttons: url("cbuttons_1.bmp");
      --wbuttons: url("eqpl.png");
    }
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color-scheme: dark;
      background: rgb(50,50,50);
      color: #eee;
      word-wrap:nowrap;
    }

    .controls button, .controls input[type="range"] {
      margin: 5px;
    }
    .controls button, #recordBtn, #recPauseBtn {
      width: 64px;
      height: 32px;
      background: var(--cbuttons);
      margin: 0px;
      padding: 0px;
      border: none;
    }
    .controls button:nth-child(1) {
      background-position: -64px 0px;
      width: 80px;
    }
    .controls button:nth-child(2) {
      background-position: -144px 0px;
      width: 80px;
    }
    .controls button:nth-child(3) {
      background-position: -224px 0px;
      width: 80px;
    }
    .controls button:nth-child(5) {
      background-position: -496px 0px;
      width:64px;
    }
    .controls button:nth-child(6) {
      background-position: -624px 0px;
      width:64px;
    }
    .controls button:nth-child(8) {
      background-position: 0px 0px;
      width:64px;
    }
    /*.controls button:nth-child(8) {
      background-position: -484px 0px;
      width:62px;
    }*/
    .controls button:nth-child(9) {
      background-position: -432px 0px;
      width:64px;
    }
    .controls button:nth-child(10) {
      background-position: -304px 0px;
      width:64px;
    }
    .controls button:nth-child(11) {
      background-position: -368px 0px;
      width:64px;
    }
    .controls #eqButton, .controls #plButton, .controls #moreButton, #recordBtn, #recPauseBtn {
      background: var(--wbuttons);
      width:32px;
      height:32px;
    }

    .controls #eqButton {
      margin-left: 16px;
    }
    .controls #eqButton:active {
      background-position: 0px -32px;
    }

    .controls #plButton {
      background-position: -32px 0px;
    }
    .controls #plButton:active {
      background-position: -32px -32px;
    }

    .controls #moreButton {
      background-position: -64px 0px;
    }
    .controls #moreButton:active {
      background-position: -64px -32px;
    }
    .controls #moreButton.activeBtn {
      background-position: -64px -64px;
    }
    .controls #moreButton.activeBtn:active {
      background-position: -64px -96px;
    }

    #recordBtn {
      background-position: -96px 0px;
    }
    #recordBtn:active {
      background-position: -96px -32px;
    }
    #recordBtn.activeBtn {
      background-position: -96px -64px;
    }
    #recordBtn.activeBtn:active {
      background-position: -96px -96px;
    }

    #recPauseBtn {
      background-position: -128px 0px;
    }
    #recPauseBtn:active {
      background-position: -128px -32px;
    }
    #recPauseBtn.activeBtn {
      background-position: -128px -64px;
    }
    #recPauseBtn.activeBtn:active {
      background-position: -128px -96px;
    }


    .controls button:nth-child(1):active {
      background-position: -64px -32px;
    }
    .controls button:nth-child(2):active {
      background-position: -144px -32px;
    }
    .controls button:nth-child(3):active {
      background-position: -224px -32px;
    }
    .controls button:nth-child(5):active {
      background-position: -496px -32px;
    }
    .controls button:nth-child(6):active {
      background-position: -624px -32px;
    }
    .controls button:nth-child(8):active {
      background-position: 0px -32px;
    }
    .controls button:nth-child(9):active {
      background-position: -432px -32px;
    }
    .controls button:nth-child(10):active {
      background-position: -304px -32px;
    }
    .controls button:nth-child(11):active {
      background-position: -368px -32px;
    }



    .controls button:nth-child(1).active {
      background-position: -64px -64px;
    }
    .controls button:nth-child(2).active {
      background-position: -144px -64px;
    }
    .controls button:nth-child(3).active {
      background-position: -224px -64px;
    }
    .controls button:nth-child(5).active {
      background-position: -496px -64px;
    }
    .controls button:nth-child(6).active {
      background-position: -624px -64px;
    }
    .controls button:nth-child(8).active {
      background-position: 0px -64px;
    }
    .controls button:nth-child(9).active {
      background-position: -432px -64px;
    }
    .controls button:nth-child(10).active {
      background-position: -304px -64px;
    }
    .controls button:nth-child(11).active {
      background-position: -368px -64px;
    }



    .controls button:nth-child(1).active:active {
      background-position: -64px -96px;
    }
    .controls button:nth-child(2).active:active {
      background-position: -144px -96px;
    }
    .controls button:nth-child(3).active:active {
      background-position: -224px -96px;
    }
    .controls button:nth-child(5).active:active {
      background-position: -496px -96px;
    }
    .controls button:nth-child(6).active:active {
      background-position: -624px -96px;
    }
    .controls button:nth-child(8).active:active {
      background-position: 0px -96px;
    }
    .controls button:nth-child(9).active:active {
      background-position: -432px -96px;
    }
    .controls button:nth-child(10).active:active {
      background-position: -304px -96px;
    }
    .controls button:nth-child(11).active:active {
      background-position: -368px -96px;
    }



    .equalizer {
      display: flex;
      gap: 4px;
      margin-top: 15px;
    }

    .equalizer input {
/*       writing-mode: bt-lr;
      -webkit-appearance: slider-vertical; */
      writing-mode: vertical-lr; direction: rtl;
      height: 100px;
      margin: 4px;
      padding: 0;
    }
    #display {
      display: block;
      width: 368px;
      height: 65px;
      background: #111; /*#111*/
    }
    #timeCounter {
      display: inline-block;
      margin: 0;
      padding: 0;
      width: 170px;
      height: 25px;
      overflow: hidden;
      white-space: nowrap;
      margin-bottom: 14px;
      margin-top: 0px;
      margin-left: 42px;
      /* background: #111; */
    }
    #timeCounter * {
      display: inline-block;
      background: url("numbers_2.png");
      width: 16px;
      height: 25px;
      margin-right: 6px;
    }
    #analyserBox {
      width: 110px;
      height: 49px;
      margin: 0;
      margin-top: -10px;
      padding: 0;
      display: inline-block;
      /* background: #fff; */
      /* background: #111; */
    }
    .analyserBar {
      background: url("spectrum_3.png");
      width: 10px;
      height: 49px;
      margin: 0;
      padding: 0;
      /* margin-right: -1px; */
      display: inline-block;
    }
    #analyserBox.bassAnalyser .analyserBar {
      background: url("level.png");
    }
    input[type=range] {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      border-image-slice:1 1 1 1;
      border-image-width:1px 1px 1px 1px;
      border-image-outset:0px 0px 0px 0px;
      border-image-repeat:repeat repeat;
      border-image-source:url("slider_bg.png");
      border-style:solid;
      background-color: #222;
      height: 2px;
    }
    input[type="range"]::-webkit-slider-thumb {
      height: 6px;
      width: 24px;
      outline: none;
      background: url('slider.png');
      -webkit-appearance: none;
      appearance: none;
      background-repeat: no-repeat;
            
    }
    #eqBars * {
      width: 2px;
      height: 200px;
    }
    .equalizer input[type="range"]::-webkit-slider-thumb {
        height: 24px;
        width: 6px;
        outline: none;
        background: url('slider_vertical.png');
        -webkit-appearance: none;
        appearance: none;
        background-repeat: no-repeat;
    }
    input[type="range"]:focus {
      outline: #666 1px solid;
    }
    #indicatorBar {
      display: block;
      margin: 0px;
      padding: 0px;
      margin-left: 42px;
      margin-bottom: 9px;
      width: 51px;
      height: 9px;
      /* outline: #f00 1px solid; */
    }
    .indicator {
      display: inline-block;
      margin: 0;
      padding: 0;
    }
    #playIndicator {
      width: 15px;
      height: 9px;
    }
    #playIndicator.activeIndicator {
      background: url('play.png');
    }
    #pauseIndicator {
      width: 9px;
      height: 9px;
      margin-left: 3px;
    }
    #pauseIndicator.activeIndicator {
      background: url('pause.png');
    }
    #repeatIndicator {
      margin-left: 3px;
      width: 21px;
      height: 9px;
      background: url('repmode.png');
    }
    #repeatIndicator.repeatIndicator1 {
      background-position: 0px -9px;
    }
    #repeatIndicator.repeatIndicator2 {
      background-position: 0px -18px;
    }
    #hiddenControls {
      border-image-slice:1 1 1 1;
      border-image-width:1px 1px 1px 1px;
      border-image-outset:0px 0px 0px 0px;
      border-image-repeat:repeat repeat;
      border-image-source:url("slider_bg.png");
      border-style:solid;
      /* background-color: #222; */
      width: 348px;
      padding: 8px;
    }
/*     *:hover {
      outline: #f00 solid 1px !important;
    } */
  </style>
</head>
<body>
  <div id="titleBar" style="font-weight: bold; font-size: 16px; margin-bottom: 10px;">
    No track
  </div>
  <div id="display">
    <div id="indicatorBar">
      <div class="indicator" id="playIndicator"></div><div class="indicator" id="pauseIndicator"></div><div class="indicator" id="repeatIndicator"></div>
    </div>
    <div id="timeCounter" style="cursor:pointer; user-select:none;/*  font-family: monospace; */">
      0:00
    </div>
    <div id="analyserBox">
      <div class="analyserBar analyserBar0"></div><div class="analyserBar analyserBar1"></div><div class="analyserBar analyserBar2"></div><div class="analyserBar analyserBar3"></div><div class="analyserBar analyserBar4"></div><div class="analyserBar analyserBar5"></div><div class="analyserBar analyserBar6"></div><div class="analyserBar analyserBar7"></div><div class="analyserBar analyserBar8"></div><div class="analyserBar analyserBar9"></div><div class="analyserBar analyserBar10"></div>
    </div>
  </div>
  <div class="controls">
    <button onclick="playAudio();this.setAttribute('class', 'active')"></button><button onclick="pauseAudio();this.setAttribute('class', 'active')"></button><button onclick="stopAudio();this.setAttribute('class', 'active')" class=""></button><!-- Hidden File Input --><input type="file" id="fileInput" accept="audio/*" multiple style="display:none"><button onclick="fileInput.click()"></button><button onclick="loadURLPrompt()"></button>
    <br>
    <button onclick="prevTrack()"></button><button onclick="nextTrack()"></button><button onclick="rewindAudio()"></button><button onclick="fastForwardAudio()"></button><button id="eqButton"></button><button id="plButton"></button><button id="moreButton" onclick="this.classList.toggle('activeBtn'); hiddenControls.style.display = this.classList.contains('activeBtn') ? '' : 'none'"></button>
    <br>
    <label for="seekbar">Seek</label><br><input type="range" id="seekbar" value="0" min="0" max="6039" step="1" style="width: 364px;margin-left:0px;"><br><br>
    <label for="volumeBar">Volume</label><br><input type="range" id="volumeBar" min="0" max="1" step="0.01" value="1" style="width: 364px;margin-left:0px;">
  </div>

  <!--<div class="equalizer" id="eqBars">
    <input type="range" min="-40" max="40" value="0" title="Preamp" style="margin-right: 32px;" id="preampBar">
  </div>-->
  <div id="hiddenControls" style="display:none">
    <button id="recordBtn"></button><button id="recPauseBtn"></button><br>
    <label for="inputLevelBar">Source/rec level</label><br><input type="range" id="inputLevelBar" min="0" max="1" step="0.01" value="1" style="margin-left:0px;width: 340px;">
    <h3>Compressor</h3>
    <div id="compressorControls">
      <label style="width: 98px;display: inline-block;" for="compThreshold">Threshold: </label><input style="width:240px" type="range" id="compThreshold" min="-100" max="0" value="-24"><br>
      <label style="width: 98px;display: inline-block;" for="compKnee">Knee:      </label><input style="width:240px" type="range" id="compKnee" min="0" max="40" value="30"><br>
      <label style="width: 98px;display: inline-block;" for="compRatio">Ratio:     </label><input style="width:240px" type="range" id="compRatio" min="1" max="20" value="12"><br>
      <label style="width: 98px;display: inline-block;" for="compAttack">Attack:    </label><input style="width:240px" type="range" id="compAttack" min="0" max="1" step="0.01" value="0.003"><br>
      <label style="width: 98px;display: inline-block;" for="compRelease">Release:   </label><input style="width:240px" type="range" id="compRelease" min="0" max="1" step="0.01" value="0.25"><br>
    </div>
    <h3>MIDI</h3>
    <div id="MIDIControls">
      Oscillator type: <select id="oscillatorType">
        <option value="sine">Sine</option>
        <option value="square">Square</option>
        <option value="triangle">Triangle</option>
        <option value="sawtooth">Sawtooth</option>
      </select>
    </div>
  </div>
  <audio id="audio" crossorigin="anonymous"></audio>

  <script>
    const audio = document.getElementById('audio');
    const seekbar = document.getElementById('seekbar');
    const volumeBar = document.getElementById('volumeBar');
    const inputLevelBar = document.getElementById('inputLevelBar');
    const fileInput = document.getElementById('fileInput');
    const urlInput = document.getElementById('urlInput');
    //let eqBars = document.querySelectorAll('#eqBars input');
    let currentTrackIndex = 0;
    let tracks = [];
    let repeatMode = 1; // 0 - don't play next track when current ends, 1 - play all playlist to the end, 2 - repeat playlist (play 1st track after last one)
    let analyserMode = 0; // 0 - spectrum (normal), 1 - bass, 2 - level
    let levelAnalyserArray = [0,0,0,0,0,0,0,0,0,0,0];
    let state = 0; // 0 - stop, 1 - play, 2 - pause
    let tracksDur = 0;
    let current_time = 0;

    let midResult;
    let midiOscillators = [];
    let midiTimeouts = [];
    let midiStartTime = 0;
    let midiCurrentTime = 0;
    let midiPlaying = false;
    let midiDuration = 0;
    let midiTempo = 500000;
    let MICROSECONDS_PER_MINUTE = 60000000;
    let isMidi = false;

/*     let midiTempos = [];
    let timeOffsets = [];
    let scheduledTimes = []; */
    let equalizerOn = false;

    repeatIndicator.classList.add(`repeatIndicator${repeatMode}`);

    if(localStorage.getItem('analyserMode') == null) {
      localStorage.setItem('analyserMode', '0');
    } else {
      analyserMode = Number(localStorage.getItem('analyserMode'));
      if(analyserMode == 1) {
        analyserBox.className = 'bassAnalyser';
      } else {
        analyserBox.className = '';
      }
    }

    // AudioContext for Equalizer
    const context = new (window.AudioContext || window.webkitAudioContext)();
    const sourceNode = context.createMediaElementSource(audio);
    let ac = context;
    const filters = [];

    const freqs = [25,
            50,
            75,
            100,
            150,
            200,
            250,
            300,
            350,
            400,
            450,
            500,
            600,
            700,
            800,
            900,
            1000,
            1250,
            1500,
            1750,
            2000,
            2500,
            3000,
            3500,
            4000,
            4500,
            5000,
            6000,
            7000,
            8000,
            9000,
            10000,
            12000,
            14000,
            16000,
            18000,
            20000];

    let timerNumbersBackgroundPositions = {
      "0":-0,
      "1":-16,
      "2":-32,
      "3":-48,
      "4":-64,
      "5":-80,
      "6":-96,
      "7":-112,
      "8":-128,
      "9":-144,
      ".":-160,
      ":":-164,
      "-":-168
    };

    let eqpreset = [0];

    for (let i = 0; i < freqs.length; i++) {
      //document.querySelector('.equalizer').innerHTML += '<input type="range" min="-40" max="40" value="0">';
      eqpreset.push(0);
    };


    //eqBars = document.querySelectorAll('#eqBars input');

    freqs.forEach((freq, i) => {
      const filter = context.createBiquadFilter();
      filter.type = "peaking";
      filter.frequency.value = freq;
      filter.Q.value = 1;
      filter.gain.value = 0;
      filters.push(filter);
    });
    const inputLevelGain = context.createGain();
    // Preamp
    const preamp = context.createGain();
// Create compressor node
const compressor = context.createDynamicsCompressor();

const analyser = context.createAnalyser();
analyser.minDecibels = -50;
analyser.maxDecibels = 10;
analyser.smoothingTimeConstant = 0.25;
analyser.fftSize = 32;

let analyserDataArray = new Uint8Array(analyser.frequencyBinCount);

const bassAnalyser = context.createAnalyser();
bassAnalyser.minDecibels = -50;
bassAnalyser.maxDecibels = 10;
bassAnalyser.smoothingTimeConstant = 0.25;
bassAnalyser.fftSize = 256;

let bassAnalyserDataArray = new Uint8Array(bassAnalyser.frequencyBinCount);



if(localStorage.getItem('equalizerOn') == null) {
  localStorage.setItem('equalizerOn', '0');
}
if(localStorage.getItem('equalizerOn') == '0') {
  equalizerOn = false;
} else if(localStorage.getItem('equalizerOn') == '1') {
  equalizerOn = true;
}

if(equalizerOn) {
  sourceNode.connect(preamp);
  filters.reduce((prev, curr) => {
    prev.connect(curr);
    return curr;
  }, preamp).connect(compressor);
} else {
  sourceNode.connect(compressor);
}

const dest = context.createMediaStreamDestination();

const mediaRecorder = new MediaRecorder(dest.stream, {mimeType:"audio/webm;codecs=pcm"});
let chunks = [];
//mediaRecorder.start();
mediaRecorder.ondataavailable = (evt) => {
  // Push each chunk (blobs) in an array
  chunks.push(evt.data);
};
            
mediaRecorder.onstop = (evt) => {
//window.ch = chunks;
  console.log(chunks);
  let blob = new Blob(chunks, { type: "audio/wav" });
  let link = document.createElement('a');
  let date = new Date();
  let resDate = `${date.getDate().toString().padStart(2, '0')}.${(date.getMonth() + 1).toString().padStart(2, '0')}.${date.getFullYear()} ${date.getHours().toString().padStart(2, '0')};${date.getMinutes().toString().padStart(2, '0')};${date.getSeconds().toString().padStart(2, '0')};${date.getMilliseconds().toString().padStart(3, '0')}`;
  link.download = 'record '+resDate+'.wav';
  link.href = URL.createObjectURL(blob);
  link.click();
  URL.revokeObjectURL(link.href);
  chunks = [];
};

let isRecording = false;
let isRecPaused = false;

recordBtn.onclick = () => {
  if(!isRecording) {
    mediaRecorder.start();
  } else {
    mediaRecorder.stop();
    isRecPaused = false;
    recPauseBtn.classList.remove('activeBtn');
  };
  isRecording = !isRecording;
  recordBtn.classList.toggle('activeBtn');
}
recPauseBtn.onclick = () => {
  if(!isRecording) return;
  if(!isRecPaused) {
    mediaRecorder.pause();
  } else {
    mediaRecorder.resume();
  };
  isRecPaused = !isRecPaused;
  recPauseBtn.classList.toggle('activeBtn');
};

const outputLevelGain = context.createGain();

// source → preamp → equalizer → compressor → input gain → analyser → bass analyser → output gain → destination
//                                                                                  → media recorder
compressor.connect(inputLevelGain).connect(analyser).connect(bassAnalyser).connect(dest);
bassAnalyser.connect(outputLevelGain).connect(context.destination);

const analyserBars = document.querySelectorAll('.analyserBar');
let analyserCounter = 0;
function updateSpectrum() {
  analyser.getByteFrequencyData(analyserDataArray);
  if(analyserMode == 0){ // spectrum
  let j = 0;  
  let k = 0;
  for (let i = 0; i < analyserBars.length; i++) {
    if(((((i+1) % 3) == 0) && ((i+1) < analyserBars.length)) || i==14) {
      // convert 16 bars to 11 by calculating the biggest value of some bar pairs
      analyserBars[j].style.backgroundPosition = `-${Math.ceil(Math.max(analyserDataArray[k], analyserDataArray[k+1])/255*5)*10}px 0px`;
      levelAnalyserArray[j]=Math.max(analyserDataArray[k], analyserDataArray[k+1]);
      k++;
    } else {
      analyserBars[j].style.backgroundPosition = `-${Math.ceil(analyserDataArray[k]/255*5)*10}px 0px`;
      levelAnalyserArray[j]=analyserDataArray[j];
    }
    j++;
    k++;
    }}else if(analyserMode == 1){ //bass
      analyserCounter++; // slows down
      if(analyserCounter == 1) {
        analyserCounter = 0;
        bassAnalyser.getByteFrequencyData(bassAnalyserDataArray);
        let bassLevel = bassAnalyserDataArray[0];
        levelAnalyserArray.unshift(bassLevel);
        levelAnalyserArray.pop();
        for (let i = 0; i < analyserBars.length; i++) {
          analyserBars[i].style.backgroundPosition = `-${Math.ceil(levelAnalyserArray[i]/255*5)*10||10}px 0px`;
        }
      }
    }else if(analyserMode == 2) { //level
      analyserCounter++; // slows down
      if(analyserCounter == 1) {
        analyserCounter = 0;
        analyser.getByteFrequencyData(analyserDataArray);
        let levelValue = Math.max(...analyserDataArray);
        levelAnalyserArray.unshift(levelValue);
        levelAnalyserArray.pop();
      for (let i = 0; i < analyserBars.length; i++) {
    
      analyserBars[i].style.backgroundPosition = `-${Math.ceil(levelAnalyserArray[i]/255*5)*10||10}px 0px`;
    
    
      }}};
  renderFavicon(levelAnalyserArray);
};
setInterval(updateSpectrum, 50);

    if(localStorage.getItem('eq_preset')==null) {
      localStorage.setItem('eq_preset', JSON.stringify(eqpreset));
    } else {
      eqpreset = JSON.parse(localStorage.getItem('eq_preset'));
      for (let i = 0; i < eqpreset.length; i++) {
        if(i==0) {
          preamp.gain.value = Math.pow(10, eqpreset[0] / 20);
          //preampBar.value = eqpreset[0];
        } else {
          filters[i-1].gain.value = eqpreset[i];
          //eqBars[i].value = eqpreset[i];     
        }
  
      }
    }
    fileInput.addEventListener("change", async (e) => {
      const files = e.target.files;
      for (let i = 0; i < files.length; i++) {
        const file = e.target.files[i];
        if(/audio\/mid/.test(file.type)) {
          let fr = new FileReader();
          fr.readAsDataURL(file);
          fr.onload = () => {
            addTrack(file.name, fr.result);
          };
        } else {
          let url1 = URL.createObjectURL(file);
          addTrack(file.name, url1);
        }
        if(i == files.length - 1) {
          tracksDur = 0;
          for (let i = 0; i < tracks.length; i++) {
            //if (!/^data:audio\/mid/.test(tracks[i].url)) {
            tracksDur += await GetFileDuration(tracks[i].url);
            //}
          }
        }
      }
    });
    
    function loadURLPrompt() {
  const url = prompt("Enter audio URL:");
  if (url) {
    addTrack(url, url);
  }
}

    async function addTrack(name, url) {
      let oldLength = tracks.length;
      tracks.push({ name, url });
      if(playlistWindow) {
        const li = playlistWindow.document.createElement('li');
        li.textContent = name;
        li.style.padding = '5px 10px';
        li.style.cursor = 'pointer';
        playlistWindow.document.querySelector('ol').appendChild(li);
      }
      //if (!(/^data:audio\/mid/.test(url))) {
        //tracksDur += await GetFileDuration(url);
      //}
      if (oldLength === 0) loadTrack(0);
    }

    function loadTrack(index) {
      const track = tracks[index];
      if (!track) return;
      audio.src = track.url;
      updateTitleBar();
      if(playlistWindow) {
        let activeLi = playlistWindow.document.querySelector('.activeTrack');
        if(activeLi) {
          activeLi.style.backgroundColor = '';
          activeLi.style.fontWeight = '';
          activeLi.className = '';
        }
        let li = playlistWindow.document.querySelectorAll('li')[index];
        li.style.backgroundColor = '#444';
        li.style.fontWeight = 'bold';
      }

      //audio.play();
      //context.resume(); // Required in some browsers to re-enable AudioContext
    }
    let playIndicatorInterval;

            
    document.getElementById('oscillatorType').addEventListener('input', getSelectedOscType);

    function getSelectedOscType(event) {
        localStorage.setItem('oscillatorType', this.value);
        this.setAttribute('selected', 'true');
        if(midiPlaying) {
          midiOscillators.forEach(track => {
            track.forEach(o => o.osc.type = this.value);
          });
        }

    };

    if(localStorage.getItem('oscillatorType') == null) {
      localStorage.setItem('oscillatorType', 'sine');
      
    }
    document.querySelector(`option[value="${localStorage.getItem('oscillatorType')}"]`).setAttribute('selected', 'true');


function playAudio() {
  if (/^data:audio\/mid/.test(tracks[currentTrackIndex].url)) {
    if (midiPlaying) return;
    isMidi = true;


    // Якщо це нове відтворення (не пауза)
    if (state === 0) {
      midResult = MidiParser.parse(tracks[currentTrackIndex].url);
      console.log(midResult);
      // Очистити старі осцилятори
      for (let i = 0; i < midiOscillators.length; i++) {
        for (let j = 0; j < midiOscillators[i].length; j++) {
          midiOscillators[i][j].osc.disconnect(midiOscillators[i][j].gain);
          midiOscillators[i][j].gain.disconnect(filters[0]);
        }
      }

      /* let minNotes = [];
      let maxNotes = []; */
      let usedNotes = [];
      let tracksWithData = [];
      
      let dataTracksAmount = 0;
      let totalOscillators = 0;

      for (let i = 0; i < midResult.track.length; i++) {
        usedNotes[i] = [];
        for (let j = 0; j < midResult.track[i].event.length; j++) {
          let event = midResult.track[i].event[j];
          if ((event.type == 9 && event.data) || (event.type == 8 && event.data)) {if(tracksWithData[i] != true){dataTracksAmount++;}
            tracksWithData[i] = true;
            //usedNotes[i] = [];
/*             if(minNotes[i] == undefined || minNotes[i] > event.data[0]) {
              minNotes[i] = event.data[0];
            }
            if(maxNotes[i] == undefined || maxNotes[i] < event.data[0]) {
              maxNotes[i] = event.data[0];
            } */if(usedNotes[i][event.data[0]] != true){totalOscillators++}
            usedNotes[i][event.data[0]] = true;
          }
        }
      }

      console.log(`tracks with music: ${dataTracksAmount}, total oscillators: ${totalOscillators}`);

      midiOscillators = [];
      for (let i = 0; i < midResult.tracks; i++) {
        if(tracksWithData[i]) {
          midiOscillators[i] = [];
          for (let j = 0; j < 128; j++) {
            if(usedNotes[i][j]) {
              let osc = ac.createOscillator();
              let gain = ac.createGain();
              osc.frequency.value = 0;
              osc.type = localStorage.getItem('oscillatorType');
              osc.connect(gain);
              gain.gain.value = 1 / 16;
              //gain.connect(preamp);
              if(Number(localStorage.getItem('equalizerOn'))) {
                gain.connect(preamp);
              } else {
                gain.connect(compressor);
              }
              osc.start();
              midiOscillators[i][j] = { osc, gain };
            }
          }
        }
      }
    }

    midiTimeouts = [];
    midiStartTime = context.currentTime - midiCurrentTime; // resume offset
    midiPlaying = true;
    midiDuration = 0;
    let timeOffset = 0;
    let scheduledTime = 0;
    //let midiTempo = 500000;
for (let i = 0; i < midResult.track.length; i++) {
      //let tempo = 500000;
      let dt = 0;

      for (let j = 0; j < midResult.track[i].event.length; j++) {
        dt += midResult.track[i].event[j].deltaTime;

        let event = midResult.track[i].event[j];
        let timeOffset = (dt / midResult.timeDivision) * (midiTempo / 1000000);

        // тільки якщо подія ще не відбулась
        if (timeOffset >= midiCurrentTime) {
          let scheduledTime = midiStartTime + timeOffset;

          if (event.type === 255 && event.metaType === 81) {
            midiTempo = event.data;
            timeOffset = (dt / midResult.timeDivision) * (midiTempo / 1000000);
          } else if (event.type === 9 && event.data) {
            let note = event.data[0];
            let freq = notesArr[note];
            midiTimeouts.push(setTimeout(() => {
              midiOscillators[i][note].osc.frequency.value = freq;
              midiOscillators[i][note].gain.gain.value = event.data[1]/127/16/* *inputLevelBar.value */;
            }, (scheduledTime - context.currentTime) * 1000));
          } else if (event.type === 8 && event.data) {
            let note = event.data[0];
            midiTimeouts.push(setTimeout(() => {
              midiOscillators[i][note].osc.frequency.value = 0;
            }, (scheduledTime - context.currentTime) * 1000));
          }

          if (timeOffset > midiDuration) {
            midiDuration = timeOffset;
          }
        };
        
      }
    }
  } else {
    audio.play();
    context.resume();
  }

  if (document.querySelector('.active')) document.querySelector('.active').setAttribute('class', '');
  clearInterval(playIndicatorInterval);
  pauseIndicator.classList.remove('activeIndicator');
  playIndicator.classList.add('activeIndicator');
  playIndicatorInterval = setInterval(() => {
    playIndicator.classList.toggle('activeIndicator');
  }, 500);
  state = 1;
}

function pauseAudio() {
  state = 2;
  if (/^data:audio\/mid/.test(tracks[currentTrackIndex].url)) {
    midiPlaying = false;
    midiCurrentTime = context.currentTime - midiStartTime;
    midiTimeouts.forEach(t => clearTimeout(t));
    midiTimeouts = [];
    // Заглушити всі частоти
    midiOscillators.forEach(track => {
      track.forEach(o => o.osc.frequency.value = 0);
    });
  } else {
    audio.pause();
  }

  if (document.querySelector('.active')) document.querySelector('.active').setAttribute('class', '');
  clearInterval(playIndicatorInterval);
  playIndicator.classList.remove('activeIndicator');
  pauseIndicator.classList.add('activeIndicator');
}
    let tmp_audio = new Audio();
    tmp_audio.preload = 'metadata';
    async function GetFileDuration(url) {

      return new Promise(resolve => {
      if(/^data:audio\/mid/.test(url)) {//alert();
        let tmpMidResult = MidiParser.parse(url);
        let tmpMidiTempo = 500000;
        let tmpTimeOffset = tmpMidiDuration = 0;
        for (let i = 0; i < tmpMidResult.track.length; i++) {
          let dt = 0;
          for (let j = 0; j < tmpMidResult.track[i].event.length; j++) {
            dt += tmpMidResult.track[i].event[j].deltaTime;
            let tmpTimeOffset = (dt / tmpMidResult.timeDivision) * (tmpMidiTempo / 1000000);
            if (tmpMidResult.track[i].event[j].type === 255 && tmpMidResult.track[i].event[j].metaType === 81) {
              tmpMidiTempo = tmpMidResult.track[i].event[j].data;
              tmpTimeOffset = (dt / tmpMidResult.timeDivision) * (tmpMidiTempo / 1000000);
            }
            if (tmpTimeOffset > tmpMidiDuration) {
              tmpMidiDuration = tmpTimeOffset;
            };
          }
        };
        resolve(tmpMidiDuration); 
      } else {
        tmp_audio.src = url;
        tmp_audio.addEventListener("loadedmetadata", () => {
          resolve(tmp_audio.duration); 
        }, {once:true});
      }

      });
    }
    async function stopAudio() {
  state = 0;
  if (/^data:audio\/mid/.test(tracks[currentTrackIndex].url)) {
    isMidi = false;
    midiPlaying = false;
    midiCurrentTime = 0;
    midiTimeouts.forEach(t => clearTimeout(t));
    midiTimeouts = [];
    if (midiOscillators.length > 0) {
      midiOscillators.forEach(track => {
        track.forEach(o => o.osc.frequency.value = 0);
      });
    };
          for (let i = 0; i < midiOscillators.length; i++) {
        for (let j = 0; j < midiOscillators[i].length; j++) {
          midiOscillators[i][j].osc.disconnect(midiOscillators[i][j].gain);
          midiOscillators[i][j].gain.disconnect(filters[0]);
        }
      }
  } else {
    audio.pause();
    audio.currentTime = 0;
  }

  if (document.querySelector('.active')) document.querySelector('.active').setAttribute('class', '');
  clearInterval(playIndicatorInterval);
  playIndicator.classList.remove('activeIndicator');
  pauseIndicator.classList.remove('activeIndicator');

  tracksDur = 0;
  for (let i = 0; i < tracks.length; i++) {
    //if (!/^data:audio\/mid/.test(tracks[i].url)) {
      tracksDur += await GetFileDuration(tracks[i].url);
    //}
  }
}

    function rewindAudio() {
      audio.currentTime = Math.max(0, audio.currentTime - 5);
    }

    function fastForwardAudio() {
      audio.currentTime = Math.min(audio.duration, audio.currentTime + 5);
    }

    function prevTrack() {
      if (currentTrackIndex > 0) {
        currentTrackIndex--;
        loadTrack(currentTrackIndex);
      }
    }

    function nextTrack(onTrackEnd) {
      if(onTrackEnd) {
        if(repeatMode == 1 && currentTrackIndex < tracks.length - 1) {
          currentTrackIndex++;
          loadTrack(currentTrackIndex);
          playAudio();
        } else if(repeatMode == 2 && !(currentTrackIndex < tracks.length - 1)) {
          currentTrackIndex = 0;
          loadTrack(currentTrackIndex);
          playAudio();
        } else if(repeatMode == 0) {
          stopAudio();
        }
      } else if (currentTrackIndex < tracks.length - 1) {
        currentTrackIndex++;
        loadTrack(currentTrackIndex);
        playAudio();
      } else if(repeatMode == 2 && !(currentTrackIndex < tracks.length - 1)) {
        currentTrackIndex = 0;
        loadTrack(currentTrackIndex);
        playAudio();
      }
    }

    // Seekbar update
    //audio.addEventListener("timeupdate", () => {
    setInterval(()=>{
      if(isMidi) {
        //midiCurrentTime = midiPlaying ? context.currentTime - midiStartTime : midiCurrentTime;
        seekbar.max = midiDuration || 5999;
        seekbar.value = Math.floor(midiPlaying ? context.currentTime - midiStartTime : midiCurrentTime);
      } else {
        seekbar.max = audio.duration || 5999;
        seekbar.value = Math.floor(audio.currentTime);
      }
    });

    seekbar.addEventListener("input", () => {
      if(isMidi) {
        if(midiPlaying) {
          pauseAudio();
          midiCurrentTime = seekbar.value;
          updateTitleBar(`Seek: ${formatTime(context.currentTime - midiStartTime)} / ${formatTime(midiDuration)} (${Math.floor((context.currentTime - midiStartTime)/midiDuration*10000)/100}%)`);
          playAudio();
        } else {
          midiCurrentTime = seekbar.value;
          updateTitleBar(`Seek: ${formatTime(context.currentTime - midiStartTime)} / ${formatTime(midiDuration)} (${Math.floor((context.currentTime - midiStartTime)/midiDuration*10000)/100}%)`);
        }
      } else {
        audio.currentTime = seekbar.value;
        updateTitleBar(`Seek: ${formatTime(audio.currentTime)} / ${formatTime(audio.duration)} (${Math.floor(audio.currentTime/audio.duration*10000)/100}%)`);
      }
});

    // Volume
    inputLevelBar.addEventListener("input", () => {
      inputLevelGain.gain.value = inputLevelBar.value;
      updateTitleBar(`Source/rec level: ${Math.round(inputLevelBar.value * 100)}%`);
    });

    volumeBar.addEventListener("input", () => {
      outputLevelGain.gain.value = volumeBar.value;
      updateTitleBar(`Volume: ${Math.round(volumeBar.value * 100)}%`);
    });

    document.getElementById('compThreshold').addEventListener('input', e => {
  compressor.threshold.value = parseFloat(e.target.value);
  updateTitleBar(`Compressor Threshold: ${e.target.value} dB`);
  localStorage.setItem('compressorThreshold', e.target.value);
});

document.getElementById('compKnee').addEventListener('input', e => {
  compressor.knee.value = parseFloat(e.target.value);
  updateTitleBar(`Compressor Knee: ${e.target.value} dB`);
  localStorage.setItem('compressorKnee', e.target.value);

});

document.getElementById('compRatio').addEventListener('input', e => {
  compressor.ratio.value = parseFloat(e.target.value);
  updateTitleBar(`Compressor Ratio: ${e.target.value}`);
  localStorage.setItem('compressorRatio', e.target.value);

});

document.getElementById('compAttack').addEventListener('input', e => {
  compressor.attack.value = parseFloat(e.target.value);
  updateTitleBar(`Compressor Attack: ${e.target.value} s`);
  localStorage.setItem('compressorAttack', e.target.value);
});

document.getElementById('compRelease').addEventListener('input', e => {
  compressor.release.value = parseFloat(e.target.value);
  updateTitleBar(`Compressor Release: ${e.target.value} s`);
  localStorage.setItem('compressorRelease', e.target.value);
});

if(localStorage.getItem('compressorThreshold') != null) {
  compressor.threshold.value = parseFloat(localStorage.getItem('compressorThreshold'));
  document.getElementById('compThreshold').value = localStorage.getItem('compressorThreshold');
}
if(localStorage.getItem('compressorKnee') != null) {
  compressor.knee.value = parseFloat(localStorage.getItem('compressorKnee'));
  document.getElementById('compKnee').value = localStorage.getItem('compressorKnee');
}
if(localStorage.getItem('compressorRatio') != null) {
  compressor.ratio.value = parseFloat(localStorage.getItem('compressorRatio'));
  document.getElementById('compRatio').value = localStorage.getItem('compressorRatio');
}
if(localStorage.getItem('compressorAttack') != null) {
  compressor.attack.value = parseFloat(localStorage.getItem('compressorAttack'));
  document.getElementById('compAttack').value = localStorage.getItem('compressorAttack');
}
if(localStorage.getItem('compressorRelease') != null) {
  compressor.release.value = parseFloat(localStorage.getItem('compressorRelease'));
  document.getElementById('compRelease').value = localStorage.getItem('compressorRelease');
}

let titleBarTimeout;
function updateTitleBar(info) {
  const titleEl = document.getElementById('titleBar');
  const track = tracks[currentTrackIndex];
  const name = track ? track.name : "No track";
  if(info) {
    clearTimeout(titleBarTimeout);
    titleEl.textContent = `${info}`;
    titleBarTimeout = setTimeout(() => {
      titleEl.textContent = `${name}`;
    }, 3000);
  } else {
    titleEl.textContent = `${name}`;
    document.head.querySelector('title').innerHTML = state > 0 ? (track?track.name:"        ㅤ"):"        ㅤ";
  }
  // titleEl.textContent = `${name} | ${info}`;
}
function formatTime(sec) {
  if (isNaN(sec)) return "00:00";
  const minutes = Math.floor(sec / 60).toString().padStart(2, "0");
  const seconds = Math.floor(sec % 60).toString().padStart(2, "0");
  return `${minutes}:${seconds}`;
}
const timeCounter = document.getElementById('timeCounter');
let timeDisplayMode = 0; // 0 = current, 1 = remaining, 2 = duration only

// Update time counter display based on mode
function updateTimeCounter() {
  if (state > 0) {
    if (isMidi) {
      const cur = midiPlaying ? context.currentTime - midiStartTime : midiCurrentTime;
      current_time = cur;
      const dur = midiDuration;
      const rem = dur - cur;
      switch (timeDisplayMode) {
        case 0:
          renderTimer(`${(currentTrackIndex+1).toString().padStart(2, ' ').padEnd(3, ' ')} ${formatTime(cur)}`);
          break;
        case 1:
          renderTimer(`${(currentTrackIndex+1).toString().padStart(2, ' ') + ' '}-${formatTime(rem)}`);
          break;
        case 2:
          renderTimer(`${(currentTrackIndex+1).toString().padStart(2, ' ').padEnd(3, ' ')} ${formatTime(dur)}`);
          break;
      }
    } else {
      const cur = audio.currentTime;
      current_time = cur;
      const dur = audio.duration || 0;
      const rem = dur - cur;
      switch(timeDisplayMode) {
        case 0:
          renderTimer(`${(currentTrackIndex+1).toString().padStart(2, ' ').padEnd(3, ' ')} ${formatTime(cur)}`);
          break;
        case 1:
          renderTimer(`${(currentTrackIndex+1).toString().padStart(2, ' ') + ' '}-${formatTime(rem)}`);
          break;
        case 2:
          renderTimer(`${(currentTrackIndex+1).toString().padStart(2, ' ').padEnd(3, ' ')} ${formatTime(dur)}`);
          break;
      }
    }
  } else {
    renderTimer(`${tracks.length.toString().padStart(2, ' ').padEnd(3, ' ')} ${formatTime(tracksDur)}`);
    current_time = tracksDur;
  }
}

// Cycle display mode on click
timeCounter.addEventListener('click', () => {
  timeDisplayMode = (timeDisplayMode + 1) % 3;
  //updateTimeCounter();
});

analyserBox.addEventListener('click', () => {
  analyserMode = (analyserMode + 1) % 3;
  localStorage.setItem('analyserMode', analyserMode);
  if(analyserMode == 1) {
    analyserBox.className = 'bassAnalyser';
  } else {
    analyserBox.className = '';
  }
});

repeatIndicator.addEventListener('click', () => {
  repeatMode = (repeatMode + 1) % 3;
  repeatIndicator.classList.remove('repeatIndicator0');
  repeatIndicator.classList.remove('repeatIndicator1');
  repeatIndicator.classList.remove('repeatIndicator2');
  repeatIndicator.classList.add(`repeatIndicator${repeatMode}`);
});

// Update counter on audio time updates and track load
//audio.addEventListener('timeupdate', updateTimeCounter);
setInterval(() => {
  updateTimeCounter();
});
audio.addEventListener('loadedmetadata', updateTimeCounter);

// Initial update
updateTimeCounter();
let playlistWindow = null;

document.getElementById('plButton').addEventListener('click', () => {
  if (playlistWindow && !playlistWindow.closed) {
    // If window is already open, close it
    playlistWindow.close();
    playlistWindow = null;
  } else {
    // Open playlist window
    playlistWindow = window.open('', 'Playlist', 'width=300,height=400,scrollbars=yes,resizable=yes');

    // Write basic HTML structure
    playlistWindow.document.title = 'Playlist';
    playlistWindow.document.body.style.fontFamily = 'Arial, sans-serif';
    playlistWindow.document.body.style.padding = '10px';
    playlistWindow.document.head.innerHTML += `<style>      body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color-scheme: dark;
      background: rgb(50,50,50);
      color: #eee;
    }</style>`;

    const heading = playlistWindow.document.createElement('h2');
    heading.textContent = 'Playlist';
    playlistWindow.document.body.appendChild(heading);

    const list = playlistWindow.document.createElement('ol');
    list.style.listStyleType = 'none';
    list.style.padding = '0';

    // Add tracks as list items
    tracks.forEach((track, index) => {
      const li = playlistWindow.document.createElement('li');
      li.textContent = track.name;
      li.style.padding = '5px 10px';
      li.style.cursor = 'pointer';

      // Highlight currently playing track
      if (index === currentTrackIndex) {
        li.style.backgroundColor = '#444';
        li.style.fontWeight = 'bold';
        li.className = 'activeTrack';
      }

      // Click to load and play track
      li.addEventListener('click', () => {
        if (window.opener) {
          window.opener.loadTrack(index);
          window.opener.updateTitleBar(`Track loaded: ${track.name}`);
        }
/*         playlistWindow.close();
        playlistWindow = null; */
      });

      list.appendChild(li);
    });

    playlistWindow.document.body.appendChild(list);

    // Focus the playlist window
    playlistWindow.focus();

    // When playlist window is closed manually, reset variable
    playlistWindow.onbeforeunload = () => {
      playlistWindow = null;
    };
  }
});





let equalizerWindow = null;

document.getElementById('eqButton').addEventListener('click', () => {
  if (equalizerWindow && !equalizerWindow.closed) {
    // If window is already open, close it
    equalizerWindow.close();
    equalizerWindow = null;
  } else {
    // Open equalizer window
   // equalizerWindow = window.open('data:text/html,<!DOCTYPE html><html><head></head><body></body></html>', 'Equalizer', 'width=640,height=400,scrollbars=yes,resizable=yes');
    //equalizerWindow.document.write('<!DOCTYPE HTML><html></html>');
    

    // Add code
    let iHTML = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>Equalizer</title>
<style>
      body {
      font-family: Arial, sans-serif;
      padding: 20px;
      color-scheme: dark;
      background: rgb(50,50,50);
      color: #eee;
    }
    input[type=range] {
                -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
border-image-slice:
1 1 1 1;
border-image-width:
1px 1px 1px 1px;
border-image-outset:
0px 0px 0px 0px;
border-image-repeat:
repeat repeat;
border-image-source:
url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADAgMAAAArRl0sAAAACVBMVEUoKCg8PDwyMjLDVyYkAAAADklEQVR4nGNgYVBhCAEAANoAfdH+EvwAAAAASUVORK5CYII=");
border-style:
solid;
background-color: #222;
width: 2px;
height:200px;
      writing-mode: vertical-lr; direction: rtl;
      margin: 4px;
      padding: 0;
    }

        input[type="range"]::-webkit-slider-thumb {
            height: 24px;
            width: 6px;
            outline: none;
            background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAYCAMAAADuznyRAAAAllBMVEVDREUmJygiIyRTVFUnKCkgISJkZWYyMzQuLy8tLi4rLCwxMjNpaWocHR4ZGhsXGBkUFRYgICAaHB0aGxwYGRoWFxhpamsbHB0VFhcYGRlqa2wdHh8gICFZWlsTFRYTFBQSExMREhMYGBi4uLiEhIRwcHBnZ2dTU1NZWVoQEREaGxscHR0ZGhoeHyBjY2QuMDEuLi8sLS4cnAWJAAAAfklEQVR4nF2OyRKCQAxEo6KyDMlsMigjIAqCu///cwYtLvblVXelUw0wY81hEbCWE1brMIoTECmSVCC0sRsFWeooV2O4ZbcrDDJE4az0sC+r+tDA8dS23XlCX8p6aLhnkDz3LpR7yK63EeKORPxFu6/TaPnk8XxF7+Rvy2/gByloCkxC7ruSAAAAAElFTkSuQmCC');
            -webkit-appearance: none;
            appearance: none;
            background-repeat: no-repeat;
        }
        input[type="range"]:focus {
          outline: #666 1px solid;
        }





   .equalizer {
      display: flex;
      gap: 4px;
      margin-top: 15px;
    }
    #enableEqualizer {

    }
      
</style></head><body><input type="checkbox" id="enableEqualizer"><label for"enableEqualizer">EQ on</label><div class="equalizer" id="eqBars"><input type="range" min="-40" max="40" value="0" title="Preamp" style="margin-right: 32px;" id="preampBar">`;

    // Add range inputs
    filters.forEach((filter, index) => {
      iHTML += `<input type="range" min="-40" max="40" value="0" title="${freqs[index]}hz">`;
    });
iHTML += `</div>
</body></html>`;
/* <!--
<scr`+`ipt>
    // Handle equalizer UI
    let eqBars = document.querySelectorAll('input');
    eqBars.forEach((slider, i) => {
      slider.addEventListener("input", () => {
        if (i > 0) {
          window.opener.filters[i-1].gain.value = parseFloat(slider.value);
          window.opener.updateTitleBar(\`EQ: \${freqs[i-1]} hz: \${slider.value} dB\`);
        } else {
          window.opener.preamp.gain.value = Math.pow(10, slider.value / 20); // dB to gain
          window.opener.updateTitleBar(\`EQ: Preamp: \${slider.value} dB\`);
        };
        window.opener.eqpreset[i] = parseFloat(slider.value);
        window.opener.localStorage.setItem('eq_preset', JSON.stringify(window.opener.eqpreset));
      });
    });
for (let i = 0; i < window.opener.eqpreset.length; i++) {
        if(i==0) {
          //preamp.gain.value = Math.pow(10, eqpreset[0] / 20);
          document.querySelector('#preampBar').value = window.opener.eqpreset[0];
        } else {
          //filters[i-1].gain.value = eqpreset[i];
          eqBars[i].value = window.opener.eqpreset[i];     
        }
  
      }
</scr`+`ipt> --> /*//**/
//equalizerWindow = window.open('data:text/html,<!DOCTYPE html><html>'+iHTML+'</html>', 'Equalizer', 'width=640,height=400,scrollbars=yes,resizable=yes');

let blob = new Blob([iHTML], { type: 'text/html'});
let url = window.URL.createObjectURL(blob);
equalizerWindow = window.open('', 'Equalizer', 'width=840,height=320,scrollbars=yes,resizable=yes');
equalizerWindow.document.write(iHTML);
equalizerWindow.document.title = 'Equalizer';
//equalizerWindow.document.documentElement.innerHTML += iHTML;
/* equalizerWindow.document.addEventListener('DOMContentLoaded',() => { */
    // Handle equalizer UI
    let eqBars = equalizerWindow.document.body.querySelectorAll('input[type="range"]');
    eqBars.forEach((slider, i) => {
      slider.addEventListener("input", () => {
        if (i > 0) {
          filters[i-1].gain.value = parseFloat(slider.value);
          updateTitleBar(`EQ: ${freqs[i-1]} hz: ${slider.value} dB`);
          slider.title = `${freqs[i-1]}hz: ${slider.value}db`;
        } else {
          preamp.gain.value = Math.pow(10, slider.value / 20); // dB to gain
          updateTitleBar(`EQ: Preamp: ${slider.value} dB`);
          slider.title = `Preamp: ${slider.value}db`;
        };
        eqpreset[i] = parseFloat(slider.value);
        localStorage.setItem('eq_preset', JSON.stringify(eqpreset));
      });
      if(i > 0) {
        slider.title = `${freqs[i-1]}hz: ${eqpreset[i]}db`;
      } else {
        slider.title = `Preamp: ${eqpreset[i]}db`;
      }
    });
for (let i = 0; i < eqpreset.length; i++) {//console.log(i);
        if(i==0) {
          //preamp.gain.value = Math.pow(10, eqpreset[0] / 20);
          equalizerWindow.document.querySelector('#preampBar').value = eqpreset[0];console.log(equalizerWindow.document.querySelector('#preampBar'));
        } else {
          //filters[i-1].gain.value = eqpreset[i];
          eqBars[i].value = eqpreset[i];     
        }
        
      }
      let enableEqualizer = equalizerWindow.document.querySelector('#enableEqualizer');
      enableEqualizer.checked = Number(localStorage.getItem('equalizerOn'));
      enableEqualizer.oninput = () => {
        if(enableEqualizer.checked) {
          sourceNode.disconnect(compressor);
          sourceNode.connect(preamp);
          filters.reduce((prev, curr) => {
            prev.connect(curr);
            return curr;
          }, preamp).connect(compressor);
          if(isMidi) {
            midiOscillators.forEach(track => {
              track.forEach((o) => {o.gain.disconnect(compressor);o.gain.connect(preamp)});
            });
          }
        } else {
          filters.reduce((prev, curr) => {
            prev.disconnect(curr);
            return curr;
          }, preamp).disconnect(compressor);
          sourceNode.connect(compressor);
          if(isMidi) {
            midiOscillators.forEach(track => {
              track.forEach((o) => {o.gain.disconnect(preamp);o.gain.connect(compressor)});
            });
          }
        }
        localStorage.setItem('equalizerOn', Number(enableEqualizer.checked));
      }
/*     }); */

    // Focus the equalizer window
    equalizerWindow.focus();

    // When equalizer window is closed manually, reset variable
    equalizerWindow.onbeforeunload = () => {
      equalizerWindow = null;
    };}
  
});






    function renderTimer(timeStr) {
      let iHTML = ``

      if(timeStr.replace(/\.\:/gmi,'').length < 8) {

      
        for (let i = 0; i < 8-timeStr.length; i++) {
          iHTML += `<span style="background: #111;"></span>`;       
        }
      }
      for (let i = 0; i < timeStr.length; i++) {
        if(timeStr[i]==' ') {
          iHTML += `<span style="background: #111;"></span>`
        } else {
          iHTML += `<span style="background-position:${timerNumbersBackgroundPositions[timeStr[i]]}px 0px;${timeStr[i]==':'||timeStr[i]=='.'?'width:4px;margin-left:-6px;margin-right:2px':''}"></span>`;
        }
      }
      timeCounter.innerHTML = iHTML;
    };
            let faviconSrcs = [
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAAOSURBVHicY2BgcABDBgADygDBN8G5RgAAAABJRU5ErkJggg==',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEUAAADL19qQ4qh8AAAAAnRSTlMA/1uRIrUAAAAMSURBVHicY1BggEIAAyoAoW+mkhsAAAAASUVORK5CYII=',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAASSURBVHicY2BgOMDAwJDAwAAABmoBIWiARTYAAAAASUVORK5CYII=',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAAOSURBVHicY2BgOMAAxgAHigGB3BlEeAAAAABJRU5ErkJggg==',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAASSURBVHicY3BgcGBgYDjAcAAABwoCAXSeLCQAAAAASUVORK5CYII=',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAASSURBVHicY2BgSGBgYDjAwAAABOoBIebnzswAAAAASUVORK5CYII=',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAASSURBVHicY2BgSGBgYHBgYAAAA2oAoeYKymkAAAAASUVORK5CYII=',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAANSURBVHicY2BgOACBAAwKAwEXyI3tAAAAAElFTkSuQmCC',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAAOSURBVHicY2BgcGAAYwACigCBdApDxQAAAABJRU5ErkJggg==',
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFAQMAAAC6v8ThAAAABlBMVEXL19oAAACsdK0MAAAAAnRSTlP/AOW3MEoAAAASSURBVHicY2BgcGBgYDjAwAAABAoBASkRAOYAAAAASUVORK5CYII='
        ];
        let faviconNumbers = [
            new Image(),
            new Image(),
            new Image(),
            new Image(),
            new Image(),
            new Image(),
            new Image(),
            new Image(),
            new Image(),
            new Image()
        ];
        for (let i = 0; i < faviconNumbers.length; i++) {
            faviconNumbers[i].src = faviconSrcs[i];
        }
    let fc = new OffscreenCanvas(16,16);
    let fctx = fc.getContext('2d');
            function renderFavicon(da) {
            //fctx.filter = 'none';
            fctx.clearRect(0,0,fc.width,fc.height);
            for (let i = 0; i < da.length; i++) {
                //fctx.fillStyle = `hsl(${120-da[i]/255*120}, 100%, 50%)`;
                fctx.fillStyle = 'rgb(203,215,218)';
                fctx.fillRect (i+2, Math.ceil(fc.height-da[i]/255*5)-7, 1, analyserMode == 1?1:Math.ceil(da[i]/255*5));
                fctx.fillStyle = 'rgb(241,89,47)';
                fctx.fillRect(i+2, 7, 1, 1);
                if(Math.ceil(da[i]/255*5)-3 > 0) {
                  fctx.fillRect (i, Math.ceil(fc.height-(da[i]/255*5-3))-12, 1, analyserMode == 1?1:Math.ceil(da[i]/255*5)-3);  
                }
                                 
            };
            let t = formatTime(current_time);
            
            /* fctx.clearRect(0,0,fc.width,fc.height); */
            for (let i = 0; i < t.length; i++) {
                /* console.log(faviconNumbers[Number(t[i])]); */
                if(faviconNumbers[Number(t[i])]) {
                    if(i == 0) {
                        fctx.drawImage(faviconNumbers[Number(t[i])], 0, 10);
                        /* console.log(faviconNumbers[Number(t[i])]); */
                    } else if(i == 1) {
                        fctx.drawImage(faviconNumbers[Number(t[i])], 4, 10);
                    } else if(i == 3) {
                        fctx.drawImage(faviconNumbers[Number(t[i])], 9, 10);
                    } else if(i == 4) {
                        fctx.drawImage(faviconNumbers[Number(t[i])], 13, 10);
                    }
                }
                /* } */                
            };
            let dataURL = fc.toDataURL("image/png", 1.0);
            favicon.href = dataURL;
        }
    audio.addEventListener("ended", ()=>{nextTrack(true)});
  </script>
  <script type="module">
  /*
    Project Name : midi-parser-js
    Project Url  : https://github.com/colxi/midi-parser-js/
    Author       : colxi
    Author URL   : http://www.colxi.info/
    Description  : MidiParser library reads .MID binary files, Base64 encoded MIDI Data,
    or UInt8 Arrays, and outputs as a readable and structured JS object.
*/

(function(){
    'use strict';

    /**
     * CROSSBROWSER & NODEjs POLYFILL for ATOB() -
     * By: https://github.com/MaxArt2501 (modified)
     * @param  {string} string [description]
     * @return {[type]}        [description]
     */
    const _atob = function(string) {
        // base64 character set, plus padding character (=)
        let b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        // Regular expression to check formal correctness of base64 encoded strings
        let b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
        // remove data type signatures at the begining of the string
        // eg :  "data:audio/mid;base64,"
        string = string.replace( /^.*?base64,/ , '');
        // atob can work with strings with whitespaces, even inside the encoded part,
        // but only \t, \n, \f, \r and ' ', which can be stripped.
        string = String(string).replace(/[\t\n\f\r ]+/g, '');
        if (!b64re.test(string))
            throw new TypeError('Failed to execute _atob() : The string to be decoded is not correctly encoded.');

        // Adding the padding if missing, for semplicity
        string += '=='.slice(2 - (string.length & 3));
        let bitmap, result = '';
        let r1, r2, i = 0;
        for (; i < string.length;) {
            bitmap = b64.indexOf(string.charAt(i++)) << 18 | b64.indexOf(string.charAt(i++)) << 12
                    | (r1 = b64.indexOf(string.charAt(i++))) << 6 | (r2 = b64.indexOf(string.charAt(i++)));

            result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255)
                    : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255)
                    : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
        }
        return result;
    };


    /**
     * [MidiParser description]
     * @type {Object}
     */
    const MidiParser  = {
        // debug (bool), when enabled will log in console unimplemented events
        // warnings and internal handled errors.
        debug: false,

        /**
         * [parse description]
         * @param  {[type]} input     [description]
         * @param  {[type]} _callback [description]
         * @return {[type]}           [description]
         */
        parse: function(input, _callback){
            if(input instanceof Uint8Array) return MidiParser.Uint8(input);
            else if(typeof input === 'string') return MidiParser.Base64(input);
            else if(input instanceof HTMLElement && input.type === 'file') return MidiParser.addListener(input , _callback);
            else throw new Error('MidiParser.parse() : Invalid input provided');
        },

        /**
         * addListener() should be called in order attach a listener to the INPUT HTML element
         * that will provide the binary data automating the conversion, and returning
         * the structured data to the provided callback function.
         */
        addListener: function(_fileElement, _callback){
            if(!File || !FileReader) throw new Error('The File|FileReader APIs are not supported in this browser. Use instead MidiParser.Base64() or MidiParser.Uint8()');

            // validate provided element
            if( _fileElement === undefined ||
                !(_fileElement instanceof HTMLElement) ||
                _fileElement.tagName !== 'INPUT' ||
                _fileElement.type.toLowerCase() !== 'file' 
            ){
                console.warn('MidiParser.addListener() : Provided element is not a valid FILE INPUT element');
                return false;
            }
            _callback = _callback || function(){};

            _fileElement.addEventListener('change', function(InputEvt){             // set the 'file selected' event handler
                if (!InputEvt.target.files.length) return false;                    // return false if no elements where selected
                console.log('MidiParser.addListener() : File detected in INPUT ELEMENT processing data..');
                let reader = new FileReader();                                      // prepare the file Reader
                reader.readAsArrayBuffer(InputEvt.target.files[0]);                 // read the binary data
                reader.onload =  function(e){
                    _callback( MidiParser.Uint8(new Uint8Array(e.target.result)));  // encode data with Uint8Array and call the parser
                };
            });
        },

        /**
         * Base64() : convert baset4 string into uint8 array buffer, before performing the
         * parsing subroutine.
         */
        Base64 : function(b64String){
            b64String = String(b64String);

            let raw = _atob(b64String);
            let rawLength = raw.length;
            let t_array = new Uint8Array(new ArrayBuffer(rawLength));

            for(let i=0; i<rawLength; i++) t_array[i] = raw.charCodeAt(i);
            return  MidiParser.Uint8(t_array) ;
        },

        /**
         * parse() : function reads the binary data, interpreting and spliting each chuck
         * and parsing it to a structured Object. When job is finised returns the object
         * or 'false' if any error was generated.
         */
        Uint8: function(FileAsUint8Array){
            let file = {
                data: null,
                pointer: 0,
                movePointer: function(_bytes){                                      // move the pointer negative and positive direction
                    this.pointer += _bytes;
                    return this.pointer;
                },
                readInt: function(_bytes){                                          // get integer from next _bytes group (big-endian)
                    _bytes = Math.min(_bytes, this.data.byteLength-this.pointer);
                    if (_bytes < 1) return -1;                                                                      // EOF
                    let value = 0;
                    if(_bytes > 1){
                        for(let i=1; i<= (_bytes-1); i++){
                            value += this.data.getUint8(this.pointer) * Math.pow(256, (_bytes - i));
                            this.pointer++;
                        }
                    }
                    value += this.data.getUint8(this.pointer);
                    this.pointer++;
                    return value;
                },
                readStr: function(_bytes){                                          // read as ASCII chars, the followoing _bytes
                    let text = '';
                    for(let char=1; char <= _bytes; char++) text +=  String.fromCharCode(this.readInt(1));
                    return text;
                },
                readIntVLV: function(){                                             // read a variable length value
                    let value = 0;
                    if ( this.pointer >= this.data.byteLength ){
                        return -1;                                                  // EOF
                    }else if(this.data.getUint8(this.pointer) < 128){               // ...value in a single byte
                        value = this.readInt(1);
                    }else{                                                          // ...value in multiple bytes
                        let FirstBytes = [];
                        while(this.data.getUint8(this.pointer) >= 128){
                            FirstBytes.push(this.readInt(1) - 128);
                        }
                        let lastByte  = this.readInt(1);
                        for(let dt = 1; dt <= FirstBytes.length; dt++){
                            value += FirstBytes[FirstBytes.length - dt] * Math.pow(128, dt);
                        }
                        value += lastByte;
                    }
                    return value;
                }
            };

            file.data = new DataView(FileAsUint8Array.buffer, FileAsUint8Array.byteOffset, FileAsUint8Array.byteLength);                                            // 8 bits bytes file data array
            //  ** read FILE HEADER
            if(file.readInt(4) !== 0x4D546864){
                console.warn('Header validation failed (not MIDI standard or file corrupt.)');
                return false;                                                       // Header validation failed (not MIDI standard or file corrupt.)
            }
            let headerSize          = file.readInt(4);                              // header size (unused var), getted just for read pointer movement
            let MIDI                = {};                                           // create new midi object
            MIDI.formatType         = file.readInt(2);                              // get MIDI Format Type
            MIDI.tracks             = file.readInt(2);                              // get ammount of track chunks
            MIDI.track              = [];                                           // create array key for track data storing
            let timeDivisionByte1   = file.readInt(1);                              // get Time Division first byte
            let timeDivisionByte2   = file.readInt(1);                              // get Time Division second byte
            if(timeDivisionByte1 >= 128){                                           // discover Time Division mode (fps or tpf)
                MIDI.timeDivision    = [];
                MIDI.timeDivision[0] = timeDivisionByte1 - 128;                     // frames per second MODE  (1st byte)
                MIDI.timeDivision[1] = timeDivisionByte2;                           // ticks in each frame     (2nd byte)
            }else MIDI.timeDivision  = (timeDivisionByte1 * 256) + timeDivisionByte2;// else... ticks per beat MODE  (2 bytes value)

            //  ** read TRACK CHUNK
            for(let t=1; t <= MIDI.tracks; t++){
                MIDI.track[t-1]     = {event: []};                                  // create new Track entry in Array
                let headerValidation = file.readInt(4);
                if ( headerValidation === -1 ) break;                               // EOF
                if(headerValidation !== 0x4D54726B) return false;                   // Track chunk header validation failed.
                file.readInt(4);                                                    // move pointer. get chunk size (bytes length)
                let e               = 0;                                            // init event counter
                let endOfTrack      = false;                                        // FLAG for track reading secuence breaking
                // ** read EVENT CHUNK
                let statusByte;
                let laststatusByte;
                while(!endOfTrack){
                    e++;                                                            // increase by 1 event counter
                    MIDI.track[t-1].event[e-1] = {};                                // create new event object, in events array
                    MIDI.track[t-1].event[e-1].deltaTime  = file.readIntVLV();      // get DELTA TIME OF MIDI event (Variable Length Value)
                    statusByte = file.readInt(1);                                   // read EVENT TYPE (STATUS BYTE)
                    if(statusByte === -1) break;                                    // EOF
                    else if(statusByte >= 128) laststatusByte = statusByte;         // NEW STATUS BYTE DETECTED
                    else{                                                           // 'RUNNING STATUS' situation detected
                        statusByte = laststatusByte;                                // apply last loop, Status Byte
                        file.movePointer(-1);                                       // move back the pointer (cause readed byte is not status byte)
                    }


                    //
                    // ** IS META EVENT
                    //
                    if(statusByte === 0xFF){                                        // Meta Event type
                        MIDI.track[t-1].event[e-1].type = 0xFF;                     // assign metaEvent code to array
                        MIDI.track[t-1].event[e-1].metaType =  file.readInt(1);     // assign metaEvent subtype
                        let metaEventLength = file.readIntVLV();                    // get the metaEvent length
                        switch(MIDI.track[t-1].event[e-1].metaType){
                            case 0x2F:                                              // end of track, has no data byte
                            case -1:                                                // EOF
                                endOfTrack = true;                                  // change FLAG to force track reading loop breaking
                                break;
                            case 0x01:                                              // Text Event
                            case 0x02:                                              // Copyright Notice
                            case 0x03:
                            case 0x04:                                              // Instrument Name
                            case 0x05:                                              // Lyrics)
                            case 0x07:                                              // Cue point                                         // Sequence/Track Name (documentation: http://www.ta7.de/txt/musik/musi0006.htm)
                            case 0x06:                                              // Marker
                                MIDI.track[t-1].event[e-1].data = file.readStr(metaEventLength);
                                break;
                            case 0x21:                                              // MIDI PORT
                            case 0x59:                                              // Key Signature
                            case 0x51:                                              // Set Tempo
                                MIDI.track[t-1].event[e-1].data = file.readInt(metaEventLength);
                                break;
                            case 0x54:                                              // SMPTE Offset
                                MIDI.track[t-1].event[e-1].data    = [];
                                MIDI.track[t-1].event[e-1].data[0] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[1] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[2] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[3] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[4] = file.readInt(1);
                                break;
                            case 0x58:                                              // Time Signature
                                MIDI.track[t-1].event[e-1].data    = [];
                                MIDI.track[t-1].event[e-1].data[0] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[1] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[2] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[3] = file.readInt(1);
                                break;
                            default :
                                // if user provided a custom interpreter, call it
                                // and assign to event the returned data
                                if( this.customInterpreter !== null){
                                    MIDI.track[t-1].event[e-1].data = this.customInterpreter( MIDI.track[t-1].event[e-1].metaType, file, metaEventLength);
                                }
                                // if no customInterpretr is provided, or returned
                                // false (=apply default), perform default action
                                if(this.customInterpreter === null || MIDI.track[t-1].event[e-1].data === false){
                                    file.readInt(metaEventLength);
                                    MIDI.track[t-1].event[e-1].data = file.readInt(metaEventLength);
                                    if (this.debug) console.info('Unimplemented 0xFF meta event! data block readed as Integer');
                                }
                        }
                    }

                    //
                    // IS REGULAR EVENT
                    //
                    else{                                                           // MIDI Control Events OR System Exclusive Events
                        statusByte = statusByte.toString(16).split('');             // split the status byte HEX representation, to obtain 4 bits values
                        if(!statusByte[1]) statusByte.unshift('0');                 // force 2 digits
                        MIDI.track[t-1].event[e-1].type = parseInt(statusByte[0], 16);// first byte is EVENT TYPE ID
                        MIDI.track[t-1].event[e-1].channel = parseInt(statusByte[1], 16);// second byte is channel
                        switch(MIDI.track[t-1].event[e-1].type){
                            case 0xF:{                                              // System Exclusive Events

                                // if user provided a custom interpreter, call it
                                // and assign to event the returned data
                                if( this.customInterpreter !== null){
                                    MIDI.track[t-1].event[e-1].data = this.customInterpreter( MIDI.track[t-1].event[e-1].type, file , false);
                                }

                                // if no customInterpretr is provided, or returned
                                // false (=apply default), perform default action
                                if(this.customInterpreter === null || MIDI.track[t-1].event[e-1].data === false){
                                    let event_length = file.readIntVLV();
                                    MIDI.track[t-1].event[e-1].data = file.readInt(event_length);
                                    if (this.debug) console.info('Unimplemented 0xF exclusive events! data block readed as Integer');
                                }
                                break;
                            }
                            case 0xA:                                               // Note Aftertouch
                            case 0xB:                                               // Controller
                            case 0xE:                                               // Pitch Bend Event
                            case 0x8:                                               // Note off
                            case 0x9:                                               // Note On
                                MIDI.track[t-1].event[e-1].data = [];
                                MIDI.track[t-1].event[e-1].data[0] = file.readInt(1);
                                MIDI.track[t-1].event[e-1].data[1] = file.readInt(1);
                                break;
                            case 0xC:                                               // Program Change
                            case 0xD:                                               // Channel Aftertouch
                                MIDI.track[t-1].event[e-1].data = file.readInt(1);
                                break;
                            case -1:                                                // EOF
                                endOfTrack = true;                                  // change FLAG to force track reading loop breaking
                                break;
                            default:
                                // if user provided a custom interpreter, call it
                                // and assign to event the returned data
                                if( this.customInterpreter !== null){
                                    MIDI.track[t-1].event[e-1].data = this.customInterpreter( MIDI.track[t-1].event[e-1].metaType, file , false);
                                }

                                // if no customInterpretr is provided, or returned
                                // false (=apply default), perform default action
                                if(this.customInterpreter === null || MIDI.track[t-1].event[e-1].data === false){
                                    console.log('Unknown EVENT detected... reading cancelled!');
                                    return false;
                                }
                        }
                    }
                }
            }
            return MIDI;
        },

        /**
         * custom function to handle unimplemented, or custom midi messages.
         * If message is a meta-event, the value of metaEventLength will be >0.
         * Function must return the value to store, and pointer of dataView needs
         * to be manually increased
         * If you want default action to be performed, return false
         */
        customInterpreter : null // function( e_type , arrayByffer, metaEventLength){ return e_data_int }
    };

        let _global = typeof window === 'object' && window.self === window && window ||
                    typeof self === 'object' && self.self === self && self ||
                    typeof global === 'object' && global.global === global && global;

        _global.MidiParser = MidiParser;


    
})();

  window.notesArr = {11:15.434,12:16.352,13:17.324,14:18.354,15:19.445,16:20.602,17:21.827,18:23.125,19:24.5,20:25.957,21:27.5,22:29.135,23:30.868,24:32.703,25:34.648,26:36.708,27:38.891,28:41.203,29:43.654,30:46.249,31:48.999,32:51.913,33:55,34:58.27,35:61.735,36:65.406,37:69.296,38:73.416,39:77.782,40:82.407,41:87.307,42:92.499,43:97.999,44:103.83,45:110,46:116.54,47:123.47,48:130.81,49:138.59,50:146.83,51:155.56,52:164.81,53:174.61,54:185,55:196,56:207.65,57:220,58:233.08,59:246.94,60:261.63,61:277.18,62:293.66,63:311.13,64:329.63,65:349.23,66:369.99,67:392,68:415.3,69:440,70:466.16,71:493.88,72:523.25,73:554.37,74:587.33,75:622.25,76:659.26,77:698.46,78:739.99,79:783.99,80:830.61,81:880,82:932.33,83:987.77,84:1046.5,85:1108.7,86:1174.7,87:1244.5,88:1318.5,89:1396.9,90:1480,91:1568,92:1661.2,93:1760,94:1864.7,95:1975.5,96:2093,97:2217.5,98:2349.3,99:2489,100:2637,101:2793.8,102:2960,103:3136,104:3322.4,105:3520,106:3729.3,107:3951.1,108:4186,109:4434.9,110:4698.6,111:4978,112:5274,113:5587.7,114:5919.9,115:6271.9,116:6644.9,117:7040,118:7458.6,119:7902.1,120:8372,121:8869.8,122:9397.3,123:9956.1,124:10548,125:11175,126:11840,127:12544,128:13290,129:14080,130:14917,131:15804,132:16744};

</script>
</body>
</html>
